## 2022年2月1日

------

- JVM ：Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）
- 好处：
  - 一次编写，到处运行
  - 自动内存管理，垃圾回收功能
  - 数组下标越界检查
  - 多态

<img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220201171535889.png" alt="image-20220201171535889" style="zoom: 50%;" />

- 内存结构

  1. **程序计数器**
  2. **虚拟机栈**
  3. **本地方法栈**
  4. **堆**
  5. **方法区**

- ![img](https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63)

- <img src="https://uploadfiles.nowcoder.com/images/20161223/415611_1482452665193_6FB53C51539B47559CF0D122A832CF63" alt="img" style="zoom:80%;" />

- **程序计数器 ：**Program Counter Register （寄存器）
  - 作用：**记住下一条jvm指令的执行地址**
  - 特点
    - 是**线程私有**的
    - 不会存在内存溢出
  - java代码的执行过程：java源代码 -> 二进制字节码 -> 解释器 -> 机器码 -> CPU
    - 解释器将会从程序计数器取得指令的执行地址
- **Java 虚拟机栈** ：Java Virtual Machine Stacks 
  - 每个**线程运行时所需要的内存**，称为虚拟机栈
  - 每个栈由多个**栈帧**（Frame）组成，对应着**每次方法调用时所占用的内存**
  - 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

  - 问题辨析
    1. 垃圾回收是否涉及栈内存？

       答：不涉及，栈内存由栈帧内存组成，而栈帧内存在方法调用结束后会弹出栈，自动回收。

    2. 栈内存分配越大越好吗？

       答：不是，栈内存越大，线程数越少。

    3. 方法内的局部变量是否线程安全？
        答：如果方法内局部变量没有逃离方法的作用范围，它是线程安全的；如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全（私有的安全，共享的需要考虑安全问题)
    
  - **栈内存溢出原因**： 1. 栈帧过多导致栈内存溢出 ； 2. 栈帧过大导致栈内存溢出

  - 线程运行诊断
    - 案例1： cpu 占用过多
      - 定位
      - 用top定位哪个进程对cpu的占用过高
      - ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
      - jstack 进程id
        - 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号
    - 案例2：程序运行很长时间没有结果 : 用jstack定位死锁

## 2022年2月2日

------

- **本地方法栈 (Native Method Stack )**：给本地方法(不是由Java代码编写的方法)的运行提供内存空间
  - 由于Java代码不能直接和操作系统底层交互，所以需要本地方法和操作系统交互。
  - 本地方法用native修饰
  - 例如Object类中的clone()、hashCode()、notify()、wait()方法等都是本地方法

- **堆（Heap)**

  - 通过 new 关键字，**创建对象都会使用堆内存**
  - 特点
    - 它是**线程共享**的，堆中对象都需要考虑线程安全的问题
    - 有**垃圾回收**机制

  - 堆内存诊断
    - jps 工具
      - 查看当前系统中有哪些 java 进程
    - jmap 工具
      - 查看堆内存占用情况 jmap - heap 进程id
    - jconsole 工具
      - 图形界面的，多功能的监测工具，可以连续监测

- **方法区**
  - Java 虚拟机有一个在所有 Java 虚拟机线程之间**共享**的方法区。它存储每个被加载过的类的信息，例如运行时常量池、属性和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法
  - 方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息
  - 方法区是在虚拟机启动时创建的
  - 如果方法区域中的内存无法满足分配请求，Java 虚拟机将抛出一个`OutOfMemoryError`.
  - JDK1.6中，方法区是以**永久代**的形式实现，存放在堆空间中
  - JDK1.8中，方法区是以**元空间**的形式实现，方法区存放在本地内存中，而运行时常量池StringTabale存放在堆中
  - 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量
    等信息
  - 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量
    池，并把里面的符号地址变为真实地址

```java
String s1 = "a";// 字符串池添加"a"
String s2 = "b";// 字符串池添加"b"
String s3 = "a" + "b";// 字符串池添加"ab"
String s4 = s1 + s2;// new StringBuilder().append("a").append("b").toString() new String("ab") 因此s3存放在堆中 (s1和s2是变量，因此在运行时动态拼接)
String s5 = "ab";// 字符串池中存在"ab"，因此不会创建新的对象，而是直接指向"ab"("a"和"b"是常量，在编译期已经确定下来了)
String s6 = s4.intern();
// 问
System.out.println(s3 == s4);
System.out.println(s3 == s5);
System.out.println(s3 == s6);
String x2 = new String("c") + new String("d");
String x1 = "cd";
x2.intern();
// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢
System.out.println(x1 == x2);
```

- **StringTable 特性**
  - 常量池中的字符串仅是符号，第一次用到时才变为对象
  - 利用串池的机制，来避免重复创建字符串对象
  - 字符串变量拼接的原理是 StringBuilder （1.8）
  - 字符串常量拼接的原理是编译期优化
  - 可以使用 **intern 方法**，主动将串池中还没有的字符串对象放入串池
    - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回
    - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回
  - 1.6 StringTable存放在永久代中； 1.8 StringTable存放在堆中
  - StringTable **性能调优**
    - 调整 -XX:StringTableSize=桶个数：适当增加StringTable桶的个数，以减少哈希冲突次数，使得StringTable效率得到提升
    - 考虑将字符串对象是否入池：如果要读取大量有重复的字符串，将字符串放入池中，能够有效节省内存空间。

## 2022年2月3日

------

- **直接内存**
  - 常见于 NIO 操作时，用于数据缓冲区 (ByteBuffer)
    - 用Java代码进行IO读取文件时，需要在堆内存缓冲区和操作系统缓冲区存储两份数据，效率低下
    - 而使用直接内存时，会在操作系统中划出一个缓冲区，Java代码可以直接访问该内存，因此效率高
  - 分配回收成本较高，但读写性能高
  - 不受 JVM 内存回收管理
    - 需要调用unsafe的freeMemory()方法来释放直接内存
    - 当Java对象被垃圾回收时，会触发unsafe回收直接内存的方法
  - **分配和回收原理**
    - 使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法
    - ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存

- **垃圾回收(重要)**
  - 引用计数法
  - **可达性分析算法**
    - Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
    - 扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收
    - 哪些对象可以作为 GC Root ?
      - System Class、Native Stack、Thread、Busy Monitor

- **四种引用(重要)**
  1. **强引用**
      只有所有 GC Roots 对象都**不通过【强引用】引用该对象**，该对象才能被垃圾回收
  2. **软引用**（SoftReference）(软引用本身会占内存)
      仅有软引用引用该对象时，在垃圾回收后，**内存仍不足时**会再次出发垃圾回收，回收软引用对象
      可以配合**引用队列**来释放软引用自身
    - 一次Full GC后，如果内存仍然不足，才会回收软引用对象
  3. **弱引用**（WeakReference）(弱引用本身会占内存)
      仅有弱引用引用该对象时，在垃圾回收时，**无论内存是否充足**，都会回收弱引用对象可以配合**引用队列**来释放弱引用自身
    - 一次Full GC后，无论内存是否充足，所有弱引用对象都会被回收
  4. **虚引用**（PhantomReference）
      必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用Cleaner相关方法(调用Unsafe.freeMemory方法)释放直接内存
  5. **终结器引用**（FinalReference）
      无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法(**不推荐使用finalize方法释放内存**，因为调用该方法的线程优先级较低），第二次 GC 时才能回收被引用对象

- 笔记地址：https://blog.csdn.net/m0_37989980/article/details/111474073

- **垃圾回收算法**
  - **标记清除**：速度较快，但是会造成内存碎片（老年代区使用）
    - 标记: 遍历GCRoot所关联的对象, 将被引用的`对象的对象头`都打上标记
    - 清除: 垃圾收集器对堆空间,进行线性遍历, 遍历到的对象,如果其对象头中没有被标记为`可达对象`, 此时就会被回收
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220203161439392.png" alt="image-20220203161439392" style="zoom:50%;" />
  - **标记整理**：速度慢，没有内存碎片（老年代区使用）
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220203161515404.png" alt="image-20220203161515404" style="zoom:50%;" />
  - **复制**：不会有内存碎片，需要占用双倍内存空间（新生代区使用）
    - 过程：将from中被引用的部分复制到to中，然后对from的内容全部清除，接下来交换from和to
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220203161835729.png" alt="image-20220203161835729" style="zoom: 50%;" />
  
- 分代垃圾回收

  - ![image-20220203163134811](C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220203163134811.png)
  - 对象首先分配在**伊甸园**区域
  - 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to
  - minor gc 会引发 **stop the world**，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行(STW是因为复制过程中会改变对象的地址，如果不暂停别的用户线程，可能会出现混乱；新生代的STW的时间较短，因为新生代采用复制算法，并且大部分都被垃圾回收了，只有少部分数据需要复制)
  - 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）
  - 如果对象的大小超过了新生代的空间，将会直接晋升至老年代(不会触发垃圾回收)，前提是老年代能放下；如果minor gc和 full gc后新生代和老年代仍放不下对象，将会内存溢出OOM
    - 注意：如果是其他线程出现了OOM，会清空该线程的占用的堆内存，不影响主线程
  - 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长（这是因为老年代的垃圾回收算法可能是标记清除 或者 标记整理，速度较慢，另外老年代的对象不是那么容易被当成垃圾回收，所以回收效率较低，STW时间较长）

## 2022年2月4日

------

- **垃圾回收器**
  - **串行**
    - 单线程
    - 堆内存较小，适合个人电脑
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220204142653866.png" alt="image-20220204142653866" style="zoom: 67%;" />
  - **吞吐量优先**(并行)
    - 多线程
    - 堆内存较大，多核 cpu
    - 让单位时间内，STW 的时间最短 ，**垃圾回收时间占比最低**，这样就称吞吐量高(0.2 0.2 = 0.4)
    - 所以核心线程都会同时进行垃圾回收，CPU占用率高
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220204142711447.png" alt="image-20220204142711447" style="zoom:67%;" />
  - **响应时间优先**（并发）
    - 多线程
    - 堆内存较大，多核 cpu
    - 尽可能让**单次 STW 的时间最短** (0.1 0.1 0.1 0.1 0.1 = 0.5)
    - ConcMarkSweepGC(**CMS)**在初始标记时，会遍历GCRoots，并标记与GCRoots直接相连的对象，此STW时间很短。
    - 初始标记完毕后，进行并发标记，此时和其他用户线程并发执行，不会暂停用户线程；
    - 并发标记结束后，会有STW，由于用户线程可能对对象进行了修改，所以需要STW，对并发标记阶段用户线程产生的新垃圾重新标记
    - 重新标记完成后，开始并发清理垃圾。
    - 只有1/4核心线程会进行垃圾回收，CPU占用率不高，但用户线程的CPU占用率只能达到75%，对吞吐量产生不利影响
    - **CMS存在的问题：**在碎片过多时，如果minor gc 不足 ，老年代 gc也不足时，会造成并发失败，老年代GC不能正常工作，这个时候垃圾回收器会退化会SerialOld，做一次单线程串行垃圾回收，等到碎片减少后才能正常工作。（垃圾回收时间会变得很长）
    - <img src="C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220204142724088.png" alt="image-20220204142724088" style="zoom:67%;" />

- **G1（Garbage First)**
  - 适用场景
    - 同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms
    - 超大堆内存，会将堆划分为多个大小相等的 Region
    - 整体上是 标记+整理 算法，两个区域之间是 复制 算法
  - 当垃圾回收速度跟不上垃圾产生的速度时，并发标记会退化为Full GC
    - 解决方案：让并发标记、混合收集提前开始

## **2022年2月7日**

------

- 泛型：泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息
  在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：
  - 泛型参数只用于编译阶段的参数检查，不影响运行阶段最终结果
  - 会自动将返回的Object进行强制类型转换

## **2022年2月8日**

------

- **类加载**
  - 三个阶段：加载 - 连接 - 初始化
- **加载**
  - 将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类
  - 如果这个类还有父类没有加载，先加载父类
  - 加载和链接可能是交替运行的

- **连接 **
  
  - 验证：验证类是否符合 JVM规范，安全性检查
  - 准备：为 static 变量分配空间，设置默认值
    - static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾
    - static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成
    - 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成
    - 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成
  - 解析：将常量池中的符号引用解析为直接引用
- **初始化**
  - <cinit>()V 方法
    初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全
  - 发生的时机
    - 概括得说，类初始化是【**懒惰的**】
      - main 方法所在的类，总会被首先初始化
      - 首次访问这个类的静态变量或静态方法时
      - 子类初始化，如果父类还没初始化，会引发
      - 子类访问父类的静态变量，只会触发父类的初始化
      - Class.forName
      - new 会导致初始化
    - 不会导致类初始化的情况
      - 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
      - 类对象.class 不会触发初始化
      - 创建该类的数组不会触发初始化
      - 类加载器的 loadClass 方法
      - Class.forName 的参数 2 为 false 时

- **类加载器**
  - ![image-20220208165040779](C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220208165040779.png)
  - 自顶而下分为：启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器
  - 根据类所在路径选择类加载器，自顶而下完成类加载
  - 双亲委派类加载模式：下级在加载之前，会依次询问上级是否已经加载过该类，如果上级已经加载过了，那么下级便不会再加载该类

- **双亲委派模式**
  - 所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则
  - 委派上级优先去加载类，上级的目录下不存在该类，再由本级进行加载（递归）。

- **线程上下文类加载器**是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由
  Class.forName 调用了线程上下文类加载器完成类加载（破坏了双亲委派，体现了面向接口编程+解耦）

- **自定义类类加载器**：以下场景中用到
  - 想加载非 classpath 随意路径中的类文件
  - 都是通过接口来使用实现，希望解耦时，常用在框架设计
  - 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器（希望不同版本的同名类文件可以一起工作）

- 认为两个类完成一致：**全限定类名和类加载器都相同**

- **运行期优化**

  - JVM 将执行状态分成了 5 个层次：

    - 0 层，解释执行（Interpreter）
    - 1 层，使用 C1 即时编译器编译执行（不带 profiling）
    - 2 层，使用 C1 即时编译器编译执行（带基本的 profiling）
    - 3 层，使用 C1 即时编译器编译执行（带完全的 profiling）
    - 4 层，使用 C2 即时编译器编译执行

  - profiling 是指在运行过程中收集一些程序执行状态的数据，例如【**方法的调用次数**】，【**循环的**
    **回边次数**】等

  - **即时编译器（JIT）与解释器的区别**

    - 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
    - JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译
    - 解释器是将字节码解释为针对所有平台都通用的机器码
    - JIT 会根据平台类型，生成平台特定的机器码

  - **JVM的优化策略**：对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由来），优化之（C1将效率提升5倍左右，C2提升10-100倍）

  - **逃逸分析**：如果发现代码内的局部变量没有被外部所调用，即没有逃逸本方法的作用范围时，将进行优化

    - 将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。
    - 同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
    - 分离对象或标量替换。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

  - **方法内联**：

    - ```java
      private static int square(final int i) {
        return i * i;
      }
      System.out.println(square(9));
      ```

    - 如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：

    - ```java
      System.out.println(9 * 9);
      ```

    - 还能够进行常量折叠（constant folding）的优化

    - ```
      System.out.println(81);
      ```

  - **字段优化**

  - **反射优化**

