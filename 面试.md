- 进程间通信方式有哪些
  - 管道、命名管道、消息队列、共享内存、信号量、信号、套接字
  
- 什么是虚拟内存？有什么好处
  - 虚拟内存是一种计算机系统内存管理技术，它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
  - 通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）
  
- HashMap为什么扩容是2倍
  - HashMap计算添加元素的位置时，使用的位运算，这是特别高效的运算；另外，HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！
  
- 怎么实现线程同步
  - Java主要通过加锁的方式实现线程同步，而锁有两类，分别是synchronized和Lock。
  
- 线程之间的通信方式
  - 1. 互斥锁 2. 读写锁 3. 条件变量 4. 信号量 5. 自旋锁 6. 屏障（barrier）
  
- 状态码

  - 200 – 请求成功

    301 – 资源(网页等)被永久转移到其它URL

    301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；

    302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；

           301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
    400 Bad Request：表示请求报文中存在语法错误；

    401 Unauthorized：未经许可，需要通过HTTP认证；

    403 Forbidden：服务器拒绝该次访问（访问权限出现问题）

    404 – 请求的资源(网页等)不存在

    500 – 内部服务器错误
    
    503 - 服务器处于超负载或者停机维护，暂时不能处理请求

- 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

- 协程与线程的区别:
  1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。

  2) 线程进程都是同步机制，而协程则是异步。

  3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。

  4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

  5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。

  6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源

- 拥塞控制：
  - 拥塞控制包括慢开始，拥塞避免，快重传，快恢复四种算法
  - 慢开始的思路是在开始阶段，将拥塞窗口的大小设置为1，然后每经过一个传输轮次，将窗口大小扩大为原来的2倍，在这个阶段，窗口的大小呈指数型增长
  - 当窗口大小达到门限值时，就会采用拥塞避免算法来减缓窗口大小的增加速率，每经过往返时间rtt将窗口大小加1
  - 快重传的思路是一旦发送方收到三个重复确认，就会立刻重新传回缺失的报文段，从而避免了继续等待计时器到期，采用快重传后可以将网络吞吐量提高20%左右
  - 快恢复是思路是当发送方收到三个重复确认后，立即将窗口大小设置为门限值的一半，然后采用拥塞避免算法，使拥塞窗口缓慢增大
  
- 在浏览器中输入 url 地址 ->> 显示主页的过程
  - 第一步，是通过DNS协议解析得到ip地址
  - 第二步，访问ip地址，通过三次握手与对方服务器建立连接
  - 第三步，浏览器发送http请求
  - 第四步，服务器处理请求，发回一个http响应
  - 第五步，浏览器解析渲染页面
  
- JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量

- 在Java中，主要有三种IO模型，分别是阻塞IO（BIO）、非阻塞IO（NIO）和 异步IO（AIO）。

- 同步（阻塞）： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。 

- 异步（非阻塞）： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果

- 关系型数据库和非关系型数据库

  - 关系型数据库的数据之间有关系，进行数据的增删改查的时候是非常方便的，支持事务，保证数据的完整性和一致性。缺点是每次操作都需要对sql语句进行解析，不能很好的满足并发需求，难以应对海量数据的增删改查。
  - 非关系型数据库高并发,读写能力强，扩展性好，缺点是不支持事务，通用性差。
  - 关系型数据库应用场景：适合处理一般量级的数据（银行转账和钱）
  - 非关系型数据库应用场景：适合处理海量数据高并发的场景

- java中实现多态的机制是什么？

  - 靠的是父类或接口的引用指向子类或实现类的对象，

    调用的方法是内存中正在运行的那个对象的方法。

- 进程切换为什么比线程慢

  - 由于进程切换会涉及到虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的转换检测缓冲区  TLB 只有一个，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。
  - 而线程切换呢，由于不涉及虚拟地址空间的切换，所以也就不存在这个问题了。

- 进程的调度算法有哪些

  - 短作业优先调度，先到先服务调度，时间片轮转调度，多级反馈队列调度，优先级调度

- 死锁产生的条件

  - 互斥，占有并等待，非抢占，循环等待，这四个条件同时成立时才会出现死锁。

- IP协议

  - IP是网络层协议，设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。

- 路由器和交换机的区别

  - 路由器工作在网络层，交换机工作在数据链路层
  - 路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换

- 进程的隔离实现

  - 使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。

- http如何实现长连接

  - header中设置Connection=keep-alive
  - 如果需要设置长连接的有效时间就在添加Keep-Alive:timeout=60

- http2.0如何做到多路复用，以及http1.1为什么不能多路复用

  - HTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少

    最大并发数问题，假设我们在 Apache 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50

    而 HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。

    HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍。

- http报文格式

  - 请求行：包含请求方法(post/get/delete/put/head)， URI，协议版本
  - 请求头：Referer(表明该请求是从哪个URI跳过来的，用于防盗链), Accept(支持的响应类型) ,Host(主机号和端口号)，Cookie，Content-Type(表示发送的数据类型)
  - 请求体：包含用户请求的信息，通常以键值对的方式传递数据

- http缓存

  - 根据是否需要重新向服务器发起请求来分类
  - 强制缓存：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

  - 对比缓存：
    - 需要进行比较判断是否可以使用缓存。
      浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
      再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。
    - 将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

- TCP首部格式

  - 源端口、目的端口、序号、确认号、确认标志位、同步标志位、窗口、校验和、紧急指针、填充

- 操作系统的组成部分

  - 1、进程管理  2、存储管理  3、文件管理  4、设备管理   5、系统调用

- 用户态和系统态

  - 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。
  - 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

- 什么是系统调用

  - 向操作系统提出服务请求，并由操作系统代为完成系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)

- LRU应用场景

  - 虚拟内存管理中，页面置换算法
  - 一般的缓存服务，如redis
  - LRU 缺点 ：可能会由于一次冷数据的批量查询而误导大量热点的数据。
  - LFU 缺点 ：最新加入的数据常常会被踢除

- 流程控制和拥塞控制的区别

  - 流量控制解决的是发送方和接收方速率不匹配的问题，发送方发送过快接收方就来不及接收和处理。采用的机制是滑动窗口的机制，控制的是发送了但未被Ack的包数量。
  - 拥塞控制解决的是避免网络资源被耗尽的问题，通过大家自律的采取避让的措施，来避免网络有限资源被耗尽。当出现丢包时，控制发送的速率达到降低网络负载的目的。

- ARP协议

  - ARP是地址解析协议的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC(计算机网卡地址)地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。

- 代理模式

  - 使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
  - 静态代理：**静态代理中，我们对目标对象的每个方法的增强都是手动完成的**，非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类)
  - 动态代理：相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类
  - JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 
  - 静态代理和动态代理的对比
    1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
    2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

- ![image-20220221170550290](C:\Users\博子\AppData\Roaming\Typora\typora-user-images\image-20220221170550290.png)

- **零拷贝**是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种`I/O`操作优化技术。


